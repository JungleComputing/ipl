#!/bin/sh

# This script can be used for running ibis applications with prun (which
# probably is only available on our own DAS system).

PRG="$0"

# resolve symlinks
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
    PRG="$link"
    else
    PRG=`dirname "$PRG"`"/$link"
    fi
done

dir=`dirname "$PRG"`
dir=`cd "$dir" && pwd`

case X$IBIS_HOME in
X)
    IBIS_HOME=`cd "$dir/.." && pwd`
    ;;
esac

export IBIS_HOME

JAVA=java
case X$JAVA_HOME in
X)	;;
*)	JAVA=$JAVA_HOME/bin/java
	;;
esac

. $dir/ns-env

# prun mangles the program name ($0) into something like
# ./ibis-prun.0.8949.fs0, which does not look nice.
NHOSTS=`echo $PRUN_HOSTNAMES | awk '{print NF}'`
case X$1 in
X$PRUN_CPU_RANK)
	case X$2 in
	X$NHOSTS)
		# User probably forgot to pass the -no-panda flag
		shift
		shift
		;;
	esac
	;;
esac

key="$PRUN_ENV"

function usage () {
cat << 'EOF'
Usage:
    prun -no-panda ibis-prun <ibis-prun params> <jvm params> <classname> <application params>
The first parameter that is not recognized as an option to ibis-prun
terminates the ibis-prun parameters.
The ibis-prun parameters are:
-attach
    set jvm parameters so that jdb can attach to the running process
-bootcp
    set the bootclasspath to the classpath. This is the default if the standard
    Java libraries have been rewritten
-no-bootcp
    don't set the bootclasspath. This is the default if the standard Java
    libraries have not been rewritten
-cp <classpath>
    sets the user classpath to the specified path. This overrides the
    CLASSPATH environment variable. Note that ibis-prun adds some directories
    and jars that are needed to run an Ibis application
-cd <dir>
    when using the javawrapper, make it change to directory <dir>
    before starting java
-cpu <cpuaffinity>
    when using the javawrapper, make it use the specified cpuaffinity
-singlecpu
    specifies that the javawrapper must be used
-no-singlecpu
    specifies that the javawrapper must not be used
-jdb
    execute jdb instead of java
-key <key>
    use <key> for identification with the nameserver, instead of the
    prun-supplied one
-no-jit
    disable just-in-time compiling
-no-pool
    don't pass on any node-pool information to the application
-n
    only print the run command, don't actually execute it
-ns <nameserver>
    specifies the hostname on which the nameserver runs
-ns-port
    specifies the port number on which the nameserver is listening
-ns-d
    use a dedicated nameserver, one of the nodes in the run is used solely
    for this purpose
-pg <prefix>
    pass profiling flags on to java, use <prefix> for the result file
-p <prefix>
    pass different profiling flags on to java, use <prefix> for the result file
-sleep <n>
    sleep <n> seconds before starting the run
-?
-h
-help
--help
    print this message
--
    terminates the parameters for ibis-prun; following parameters are passed
    on to java, even if they would be acceptable to ibis-prun
EOF
	exit 1
}

if [ -z "$1" -o $# -le 0 ]
then
	usage
fi

#
# Some defaults ...
#

cpumask="1"
dedicated_nameserver=0
no_pool=0
ncluster=0
ibislib=$IBIS_HOME/lib/natives

USE_JAVAWRAPPER=0

dir=$PWD

#
# parse arguments
#

args=

while [ $# -gt 0 ]
do
# echo now inspect argument $1 -- left $#
        case "$1" in
	-attach)
		args="$args $1"
		;;
        -cd)
		shift
		dir="$1"
                ;;
	-ncluster)
		shift
		ncluster="$1"
		;;
	-ibislib)
		shift
		ibislib="$1"
		;;
        -cpu)
		shift
		cpumask="$1"
                ;;
	-singlecpu)
		USE_JAVAWRAPPER=1
		;;
	-no-singlecpu)
		USE_JAVAWRAPPER=0
		;;
	-jdb)
		args="$args $1"
		;;
	-key)
		shift
		key="$1"
		;;
	-no-jit)
		args="$args $1"
		;;
	-no-bootcp)
		args="$args $1"
		;;
	-bootcp)
		args="$args $1"
		;;
	-hubport|-hub-port)
		args="$args $1"
		shift
		args="$args $1"
		;;
	-controlhub)
		args="$args $1"
		;;
	-no-pool)
		no_pool=1
		;;
	-n)
		args="$args $1"
		;;
	-ns)
		shift
		args="$args -ns $1"
		;;
	-cp)
		shift
		classpath="$1"
		args="$args -cp $1"
		;;
	-pg)
		shift
		gprof="$1"
		;;
	-p)
		shift
		prof="$1"
		;;
	-ns-port)
		shift
		args="$args -ns-port $1"
		;;
	-ns-d)
		dedicated_nameserver=1
		;;
	-karmi)
		args="$args $1"
		;;
	-karmi-gm)
		args="$args $1"
		;;
	-ip-map)
		shift
		args="$args -ip-map $1"
		ip_map="$1"
		export HOSTS="`$IBIS_HOME/bin/ip_map.perl $ip_map $HOSTS`"
		export PRUN_HOSTNAMES="`$IBIS_HOME/bin/ip_map.perl $ip_map $PRUN_HOSTNAMES`"
		;;
	-sleep)
		shift
		args="$args -sleep $1"
		;;
	-\?|-h|-help|--help)
		usage
		;;
	--)
		shift
		break
		;;
        *)      
		break
                ;;
        esac
        shift
done

if [ ! -z "$prof" ]
then
	JIT_OPTS="$JIT_OPTS -Xrunhprof:cpu=samples,depth=8,thread=y,file=$prof.$PRUN_CPU_RANK -Djava.compiler=NONE"
fi
if [ ! -z "$gprof" ]
then
	# JIT_OPTS="$JIT_OPTS -Xrunhprof:cpu=times,depth=8,thread=y,file=$gprof.$PRUN_CPU_RANK -Djava.compiler=NONE"
	JIT_OPTS="$JIT_OPTS -Xrunhprof:cpu=times,depth=8,thread=y,file=$gprof.$PRUN_CPU_RANK"
fi

wrapper_name="$IBIS_HOME/bin/java_wrapper"

# Given a list, return the last element
function last_array_elt () {
	local last
	for h ; do last=$h ; done
	echo $last
}

# Given a list, return a list with the last element stripped
# bash cannot slice for you, so we use an intermediate array
# for the manipulations.
function strip_array () {
	local i=0
	local -a ARRAY
	for h ; do
		ARRAY[$i]=$h
		i=`expr $i + 1`
	done
	local RESULT="${ARRAY[0]}"
	for (( i = 1; i < $# - 1; i++ )) ; do
		RESULT="$RESULT ${ARRAY[$i]}"
	done
	echo "$RESULT"
}

i_am_nameserver=0
if [ $dedicated_nameserver -eq 1 ]
then
	# A dedicated nameserver is run on HOSTS[#HOSTS - 1]
	# The last entry in HOSTS and PRUN_HOSTNAMES is stripped.

	ns=`last_array_elt $HOSTS`
	# echo ns $ns
	args="$args -ns $ns"

	NHOSTS=`expr $NHOSTS - 1`
	export HOSTS=`strip_array $HOSTS`
	export PRUN_HOSTNAMES=`strip_array $PRUN_HOSTNAMES`
	if  [ $PRUN_CPU_RANK -eq $NHOSTS ] ; then
	    i_am_nameserver=1
	fi
fi

hosts="$HOSTS"

i_am_cluster_coord=0
if [ $ncluster -gt 0 ]
then
    i=`expr $NHOSTS - $ncluster`
    while [ $i -lt $NHOSTS ]
    do
	hosts=`strip_array $hosts`
	if [ $PRUN_CPU_RANK -eq $i ]
	then
	    i_am_cluster_coord=1
	fi
	i=`expr $i + 1`
    done
fi

NHOSTS=`expr $NHOSTS - $ncluster`

LIBCLASSPATH=""

add_to_libclasspath () {
    DIRLIBS=`cd "$1" && ls *.jar 2>/dev/null`
    for i in ${DIRLIBS}
    do
	if [ -z "$LIBCLASSPATH" ] ; then
	    LIBCLASSPATH="$1/$i"
	else
	    LIBCLASSPATH="$1/$i":$LIBCLASSPATH
	fi
    done
}

# Add the following dirs to the classpath 
add_to_libclasspath ${IBIS_HOME}/lib

export ibislib

if [ $USE_JAVAWRAPPER -eq 1 ]
then
	action="$wrapper_name -cpu $cpumask -cd $dir"
fi

if [ $i_am_nameserver -eq 1 ]
then
	echo Start run-once name server on `hostname`
	JAVACLASSPATH="$LIBCLASSPATH:"
	$JAVA \
		-classpath $JAVACLASSPATH \
		ibis.impl.nameServer.tcp.NameServer -single
elif [ $i_am_cluster_coord -eq 1 ]
then
	JAVACLASSPATH="$LIBCLASSPATH:"
	export LFC_INTR_FIRST=100
	$JAVA \
		-classpath $JAVACLASSPATH \
		-Dibis.library.path="$ibislib" \
		ibis.impl.messagePassing.PandaIbis
else
	if [ $no_pool -eq 0 ]
	then
		. $IBIS_HOME/bin/ibis-run -action "$action" $args \
				-key "$key" \
				-nhosts $NHOSTS \
				-hosts "$hosts" \
				-hostno $PRUN_CPU_RANK -- "$@"
	else
		. $IBIS_HOME/bin/ibis-run -action "$action" $args \
				-key "$key" \
				-- "$@"
	fi
fi
