#
# This file describes the capabilities that can be associated with
# an Ibis implementation. The format of this file is described
# in the java.util.Properties.load() API.
#
# Properties must be formulated in such a way that a suitable Ibis
# implementation can be selected by specifying the required capabilities,
# and specifying which capabilities might come in handy.
#
# Note that an Ibis application may later on only create port types
# with capabilities that are a subset of the capabilities supplied by
# the Ibis implementation, and not ask for capabilities that were not
# required or specified to come in handy.
#
# Most, if not all, capabilities are of a boolean type. Their presence
# implies that the capability is requested. In capability names,
# case is ignored.
#
# The list presented here is not complete, and cannot be. Future Ibis
# implementations may specify capabilities that are not present here, and
# applications may request them. If an application requests capabilities that
# cannot be found in any Ibis implementation, no Ibis instance can be created
# and the application is notified.
#
conn.onetomany:
#	one-to-many communication is supported (in Ibis terms: a sendport
#	may connect to multiple receiveports).
conn.manytoone:
#	many-to-one communication is supported (in Ibis terms: multiple
#	sendports may connect to a single receiveport).
conn.downcalls:
#	connection downcalls are supported.
conn.upcalls:
#	connection upcalls are supported.
conn.timeout:
#	connection attempts with a timeout are supported.
recv.explicitreceipt:
#       explicit receive is supported.
recv.timeout:
#       blocking receives with a timeout are supported.
recv.poll:
#	poll is supported.
recv.autoupcalls:
#	message upcalls are supported and polling for them is not required.
recv.pollupcalls:
#	message upcalls are supported but polling for them is required. When an
#	Ibis implementation claims that it has this, it may also do
#	recv.autoupcalls, but polling does no harm. When an application asks
#	for this (and not recv.autoupcalls), it must poll.
#       Note: for this to work, poll must be supported and requested!
comm.fifo:
#   	messages from a sendport are delivered to its receiveports in the
#   	order in which they were sent.
comm.numbered:
#	messages from sendports of a port type with this property are
#	given global sequence numbers so that the application can order
#	them. The numbering is per port type.
comm.reliable:
#	reliable communication is supported.


# Model capabilities are:
worldmodel.open:
#	this means that Ibises can join the run at any time.
worldmodel.closed:
#	this means that the Ibises that can join the run are determined
#	at the start of the run.
# Note that Ibis implementations may support both.


# Serialization capabilities are:
serialization.byte:
#	readByte/writeByte and readArray/writeArray(byte[]) are supported.
serialization.data:
#	read/write and readArray/writeArray of primitive types are supported.
#	readString and writeString are also supported.
serialization.object:
#	Some sort of object serialization is supported. This is sufficient if
#       all writeObject/readObject methods are symmetrical, t.i. readObject
#       reads everything that writeObject writes, and no versioning support
#       is needed (object versions are the same on both ends).
serialization.strictobject:
#	Specify this if you depend on the Sun version of object serialization.

# Finally, specific ibis implementations can be given nicknames. An example:
nickname:tcp
# This property can be requested when creating an Ibis.
