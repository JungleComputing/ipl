/* $Id$ */

package ibis.ipl;

import java.io.InputStream;
import java.io.IOException;

/**
 * Base class for Ibis implementations. All Ibis implementations must
 * extend this class.
 */

public abstract class Ibis {

    /** A user-supplied resize handler, with join/leave upcalls. */
    protected ResizeHandler resizeHandler;

    /**
     * Properties, as given to
     * {@link #createIbis(StaticProperties, ResizeHandler)}
     */
    protected StaticProperties requiredProps;

    /** User properties, combined with required properties. */
    protected StaticProperties combinedProps;

    /** Don't allow public creation. */
    protected Ibis() {
    	// nothing here
    }

    /**
     * Initializes the fields of this class with the specified values.
     * @param resizeHandler the resizeHandler specified by the caller
     * of {@link ibis.ipl.IbisFactory#createIbis()}.
     * @param requiredProps properties as specified by caller of
     * {@link ibis.ipl.IbisFactory#createIbis()}.
     * @param combinedProps properties that are the result of the combination
     * of <code>requiredProps</code> and the user-specified properties.
     * @exception IOException may be thrown when something goes wrong
     * in the Ibis implementation-specific part.
     */
    protected void init(ResizeHandler resizeHandler,
            StaticProperties requiredProps, StaticProperties combinedProps)
            throws IOException {
        this.resizeHandler = resizeHandler;
        this.requiredProps = requiredProps;
        this.combinedProps = combinedProps;
    }

    /**
     * When running closed-world, returns the total number of Ibis instances
     * involved in the run. Otherwise returns -1.
     * @return the number of Ibis instances
     * @exception NumberFormatException is thrown when the property
     *   ibis.pool.total_hosts is not defined or does not represent a number.
     */
    public abstract int totalNrOfIbisesInPool();

    /**
     * Allows reception of {@link ibis.ipl.ResizeHandler ResizeHandler}
     * upcalls.
     * If a {@link ibis.ipl.ResizeHandler ResizeHandler} is installed,
     * this call blocks until its
     * {@link ibis.ipl.ResizeHandler#joined(IbisIdentifier) joined()}
     * upcall for this Ibis is invoked.
     */
    public abstract void enableResizeUpcalls();

    /**
     * Disables reception of
     * {@link ibis.ipl.ResizeHandler ResizeHandler} upcalls.
     */
    public abstract void disableResizeUpcalls();

    /**
     * Returns all Ibis recources to the system.
     * @exception IOException is thrown when an error occurs.
     */
    public abstract void end() throws IOException;

    /**
     * Creates a {@link ibis.ipl.PortType PortType}.
     * Port properties are specified (for example ports are "OneToOne",
     * with "Ibis serialization").
     * If no static properties are given, the properties that were
     * requested from the Ibis implementation are used, possibly combined
     * with properties specified by the user (using the
     * -Dibis.&#60category&#62="..." mechanism).
     * If static properties <strong>are</strong> given,
     * the default properties described above are used for categories 
     * not specified by the given properties.
     * <p>
     * The properties define the <code>PortType</code>.
     * If two Ibis instances want to communicate, they must both
     * create a <code>PortType</code> with the same properties.
     * A <code>PortType</code> can be used to create
     * {@link ibis.ipl.ReceivePort ReceivePorts} and
     * {@link ibis.ipl.SendPort SendPorts}.
     * Only <code>ReceivePort</code>s and <code>SendPort</code>s of
     * the same <code>PortType</code> can communicate.
     * Any number of <code>ReceivePort</code>s and <code>SendPort</code>s
     * can be created on a JVM (even of the same <code>PortType</code>).
     * </p>
     * @param p properties of the porttype.
     * @return the porttype.
     * @exception ibis.ipl.PortMismatchException if the required properties
     * do not match the properties as specified when creating the Ibis
     * instance.
     */
    public abstract PortType createPortType(StaticProperties p)
            throws PortMismatchException;

    /** 
     * Returns the Ibis {@linkplain ibis.ipl.Registry Registry}.
     * @return the Ibis registry.
     */
    public abstract Registry registry();

    /**
     * Returns the properties of this Ibis implementation.
     * @return the properties of this Ibis implementation.
     */
    public StaticProperties properties() {
        return IbisFactory.staticProperties(this.getClass().getName());
    }

    /**
     * Polls the network for new messages.
     * An upcall may be generated by the poll. 
     * There is one poll for the entire Ibis, as this
     * can sometimes be implemented more efficiently than polling per
     * port. Polling per port is provided in the receiveport itself.
     * @exception IOException is thrown when a communication error occurs.
     */
    public abstract void poll() throws IOException;

    /**
     * Returns an Ibis {@linkplain ibis.ipl.IbisIdentifier identifier} for
     * this Ibis instance.
     * An Ibis identifier identifies an Ibis instance in the network.
     * @return the Ibis identifier of this Ibis instance.
     */
    public abstract IbisIdentifier identifier();

    /**
     * Returns the current Ibis version.
     * @return the ibis version.
     */
    public String getVersion() {
        InputStream in
            = ClassLoader.getSystemClassLoader().getResourceAsStream("VERSION");
        String version = "Unknown Ibis Version ID";
        if (in != null) {
            byte[] b = new byte[512];
            int l = 0;
            try {
                l = in.read(b);
            } catch (Exception e) {
                // Ignored
            }
            if (l > 0) {
                version = "Ibis Version ID " + new String(b, 0, l);
            }
        }
        return version + ", implementation = " + this.getClass().getName();
    }

    public void printStatistics() { 
        // default is empty
    }
}
