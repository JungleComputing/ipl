package ibis.ipl.impl.stacking.cc;

import ibis.ipl.ReceivePort;
import ibis.ipl.ReceivePortConnectUpcall;
import ibis.ipl.SendPortIdentifier;
import ibis.ipl.impl.stacking.cc.util.CCStatistics;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This class forwards upcalls with the proper receive port.
 */
public class ReceivePortConnectionUpcaller
        implements ReceivePortConnectUpcall {
    
    private final static Logger logger = 
            LoggerFactory.getLogger(ReceivePortConnectionUpcaller.class);

    CCReceivePort recvPort;
    ReceivePortConnectUpcall upcaller;

    public ReceivePortConnectionUpcaller(ReceivePortConnectUpcall upcaller,
            CCReceivePort port) {
        this.recvPort = port;
        this.upcaller = upcaller;
    }

    @Override
    public boolean gotConnection(ReceivePort me,
            SendPortIdentifier spi) {
        logger.debug("\t{} got connection from {}", 
                new Object[] {recvPort.identifier(), spi});

        boolean accepted = true;

        recvPort.ccManager.lock.lock();
        logger.debug("Lock locked.");
        try {
            if (recvPort.ccManager.isConnCached(this.recvPort.identifier(), spi)) {
                logger.debug("Restoring connection from {}\n", spi);
                // connection was cached
                recvPort.ccManager.restoreReservedConnection(recvPort.identifier(), spi);
            } else {
                if (upcaller != null) {
                    accepted = upcaller.gotConnection(recvPort, spi);
                }
                logger.debug("New connection from {}\n", spi);
                // new connection
                recvPort.ccManager.activateReservedConnection(recvPort.identifier(), spi);
            }
        } finally {
            logger.debug("Unlocking lock.");
            recvPort.ccManager.lock.unlock();            
        }
        
        if(accepted) {
            CCStatistics.connect(recvPort.identifier(), spi);
        }

        return accepted;
    }

    /**
     * This method is called in one of the following situations: 
     * 1) a true
     * disconnect()/close() from the receive port 
     * 2) a connection caching (but
     * the SPI would be in the toBeCachedSet thanks to the side channel) 
     * 3) a
     * disconnect/close is called from the receive port, but the connection was
     * cached; (the disc/close is sent through the side channel; to mark this, I
     * set "me" to null) 
     * 4) a disconnect/close generated by a caching initiated
     * from this side; the side channel sends the caching msg to sendport and it
     * will close this connection.
     */
    @Override
    public void lostConnection(ReceivePort me,
            SendPortIdentifier spi, Throwable reason) {
        logger.debug("\n\t{} Got LOST connection to {}",
                new Object[]{recvPort.identifier(), spi});
        if (reason != null) {
            logger.debug("\tLOST connection cause:\t", reason);
        }
        
        boolean isCached = false;

        recvPort.ccManager.lock.lock();
        logger.debug("\n\tLock locked. me={}", recvPort.identifier());
        try {
            /*
             * Sync-ed because the place from where the caching was initiated
             * would like a notification on when it has actually been
             * accomplished.
             */
            synchronized (recvPort.cachingInitiatedByMeSet) {
                if (recvPort.cachingInitiatedByMeSet.contains(spi)) {
                    logger.debug("Got lost connection"
                            + " initiated by me. Connection now trully cached"
                            + " from {} to {}.",
                            new Object[]{spi, recvPort.identifier()});
                    /*
                     * The connection is cached because I wanted it cached.
                     * scenario 4)
                     */
                    /*
                     * Don't call port.cacheManager.cacheConnection() because
                     * this connection caching was initiated by me from some
                     * place, so I already know of this cached connection.
                     */
                    recvPort.cachingInitiatedByMeSet.remove(spi);
                    recvPort.cachingInitiatedByMeSet.notifyAll();

                    isCached = true;
                }
            }
            
            if (recvPort.toBeCachedSet.contains(spi)) {
                /*
                 * This disconnect call is actually a connection caching.
                 * scenario 2).
                 */
                recvPort.ccManager.unReserveLiveToCacheConnection(recvPort.identifier(), spi);
                recvPort.toBeCachedSet.remove(spi);
                
                logger.debug("Got lost connection. This"
                        + " connection will be cached because the send port {} "
                        + " asked it.", spi);

                isCached = true;
            }
            
            if(isCached) {
                CCStatistics.cache(recvPort.identifier(), spi);
                return ;
            }


            /*
             * The connection was cached (scenario 3) 
             * or 
             * it is alive (scenario 1),
             * but now it needs to be closed.
             */
            recvPort.ccManager.removeConnection(recvPort.identifier(), spi);
            if (upcaller != null) {
                logger.debug("Lost connection user upcall starting...");
                upcaller.lostConnection(recvPort, spi, reason);
                logger.debug("Lost connection user upcall finished.");
            }
            
            CCStatistics.remove(recvPort.identifier(), spi);
        } finally {
            logger.debug("Unlocking lock...");
            recvPort.ccManager.lock.unlock();
        }
    }
}
