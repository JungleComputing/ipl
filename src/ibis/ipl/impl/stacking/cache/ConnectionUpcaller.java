package ibis.ipl.impl.stacking.cache;

import ibis.ipl.ReceivePort;
import ibis.ipl.ReceivePortConnectUpcall;
import ibis.ipl.SendPortIdentifier;
import ibis.ipl.impl.stacking.cache.manager.CacheManager;
import java.util.logging.Level;

/**
 * This class forwards upcalls with the proper receive port.
 */
public class ConnectionUpcaller
        implements ReceivePortConnectUpcall {

    CacheReceivePort port;
    ReceivePortConnectUpcall upcaller;

    public ConnectionUpcaller(ReceivePortConnectUpcall upcaller,
            CacheReceivePort port) {
        this.port = port;
        this.upcaller = upcaller;
        CacheManager.log.log(Level.INFO, "Created ConnectionUpcaller");
    }

    /*
     * Sync-ed so no lost connection may come when a connection upcall
     * is still alive.
     */
    @Override
    public synchronized boolean gotConnection(ReceivePort me,
            SendPortIdentifier spi) {
        if (port.closed) {
            return false;
        }
        CacheManager.log.log(Level.INFO, "Got Connection");

        boolean accepted = true;

        if (upcaller != null) {
            accepted = upcaller.gotConnection(port, spi);
        }

        if (!accepted) {
            return false;
        }

        synchronized (port.cacheManager) {
            if (port.falselyConnected.contains(spi)) {
                // connection was cached
                port.falselyConnected.remove(spi);
                port.cacheManager.restoreConnection(port.identifier(), spi);
                port.cacheManager.notifyAll();
            } else {
                // new connection
                port.cacheManager.addConnection(port.identifier(), spi);
                port.logicallyAlive.add(spi);
            }
            port.cacheManager.notifyAll();
        }

        return true;
    }

    /**
     * Synchronized in order to guarantee that at most 1 is alive at any time,
     * because this method is also called manually from the side channel
     * handling class.
     *
     * This method is called in one of the following situations: 1) a true
     * disconnect()/close() from the receive port 2) a connection caching (but
     * the SPI would be in the toBeCachedSet thanks to the side channel) 3) a
     * disconnect/close is called from the receive port, but the connection was
     * cached; (the disc/close is sent through the side channel; to mark this, I
     * set "me" to null) 4) a disconnect/close generated by a caching initiated
     * from this side; the side channel sends the caching msg to sendport and it
     * will close this connection.
     */
    @Override
    public synchronized void lostConnection(ReceivePort me,
            SendPortIdentifier spi, Throwable reason) {
        CacheManager.log.log(Level.INFO, "\n\tGot lost connection....");
        if (reason != null) {
            CacheManager.log.log(Level.INFO, "\tbecause of exception:\n{0}", reason.toString());
        }

        synchronized (port.cacheManager) {

            if (me == null) {
                /*
                 * The connection was cached, but now it needs to be closed.
                 * scenario 3).
                 */
                port.cacheManager.removeConnection(me.identifier(), spi);
                port.falselyConnected.remove(spi);
                port.logicallyAlive.remove(spi);
            } else if (port.toBeCachedSet.contains(spi)) {
                /*
                 * This disconnect call is actually a connection caching.
                 * scenario 2).
                 */
                port.cacheManager.cacheConnection(me.identifier(), spi);
                port.toBeCachedSet.remove(spi);
                port.falselyConnected.add(spi);
            } else if (port.initiatedCachingByMe.contains(spi)) {
                /*
                 * The connection is cached because 
                 * I wanted it cached. scenario 4)
                 */
                /*
                 * Don't call port.cacheManager.cacheConnection()
                 * because this connection caching was initiated by
                 * me from some place, so I already know of this cached connection.
                 */
//                port.cacheManager.cacheConnection(me.identifier(), spi);
                /*
                 * Sync-ed because the place from where the caching was
                 * initiated would like a notification on when it has
                 * actually been accomplished.
                 */
                synchronized(port.initiatedCachingByMe) {
                    port.initiatedCachingByMe.remove(spi);
                    port.initiatedCachingByMe.notifyAll();
                }
                port.falselyConnected.add(spi);
            } else {
                /*
                 * This connection is lost for good - and it was't cached.
                 * scenario 1).
                 */
                port.cacheManager.removeConnection(me.identifier(), spi);
                port.logicallyAlive.remove(spi);
            }
            port.cacheManager.notifyAll();
        }

        if (upcaller != null) {
            upcaller.lostConnection(port, spi, reason);
        }
    }
}
