package ibis.ipl.impl.stacking.cache;

import ibis.ipl.ReceivePort;
import ibis.ipl.ReceivePortConnectUpcall;
import ibis.ipl.SendPortIdentifier;
import ibis.ipl.impl.stacking.cache.util.CacheStatistics;
import ibis.ipl.impl.stacking.cache.util.Loggers;
import java.util.logging.Level;

/**
 * This class forwards upcalls with the proper receive port.
 */
public class ReceivePortConnectionUpcaller
        implements ReceivePortConnectUpcall {

    CacheReceivePort recvPort;
    ReceivePortConnectUpcall upcaller;

    public ReceivePortConnectionUpcaller(ReceivePortConnectUpcall upcaller,
            CacheReceivePort port) {
        this.recvPort = port;
        this.upcaller = upcaller;
    }

    @Override
    public boolean gotConnection(ReceivePort me,
            SendPortIdentifier spi) {
        Loggers.conLog.log(Level.INFO, "\t{0} got connection", recvPort.identifier());

        boolean accepted = true;

        recvPort.cacheManager.lock.lock();
        Loggers.lockLog.log(Level.INFO, "Lock locked.");
        try {
            if (recvPort.cacheManager.isConnCached(this.recvPort.identifier(), spi)) {
                Loggers.conLog.log(Level.INFO, "\t\trestoring from {0}\n", spi);
                // connection was cached
                recvPort.cacheManager.restoreReservedConnection(recvPort.identifier(), spi);
            } else {
                if (upcaller != null) {
                    accepted = upcaller.gotConnection(recvPort, spi);
                }
                Loggers.conLog.log(Level.INFO, "\t\tnew from {0}\n", spi);
                // new connection
                recvPort.cacheManager.activateReservedConnection(recvPort.identifier(), spi);
            }
        } finally {
            recvPort.cacheManager.lock.unlock();
            Loggers.lockLog.log(Level.INFO, "Lock unlocked.");
        }
        
        if(accepted) {
            CacheStatistics.connect(recvPort.identifier(), spi);
        }

        return accepted;
    }

    /**
     * This method is called in one of the following situations: 
     * 1) a true
     * disconnect()/close() from the receive port 
     * 2) a connection caching (but
     * the SPI would be in the toBeCachedSet thanks to the side channel) 
     * 3) a
     * disconnect/close is called from the receive port, but the connection was
     * cached; (the disc/close is sent through the side channel; to mark this, I
     * set "me" to null) 
     * 4) a disconnect/close generated by a caching initiated
     * from this side; the side channel sends the caching msg to sendport and it
     * will close this connection.
     */
    @Override
    public void lostConnection(ReceivePort me,
            SendPortIdentifier spi, Throwable reason) {
        Loggers.conLog.log(Level.INFO, "\n\t{0} got lost connection to {1}",
                new Object[]{recvPort.identifier(), spi});
        if (reason != null) {
            Loggers.conLog.log(Level.WARNING, "\tbecause of cause:\t", reason);
        }
        
        boolean isCached = false;

        recvPort.cacheManager.lock.lock();
        Loggers.lockLog.log(Level.INFO, "Lock locked.");
        try {
            /*
             * Sync-ed because the place from where the caching was initiated
             * would like a notification on when it has actually been
             * accomplished.
             */
            synchronized (recvPort.cachingInitiatedByMeSet) {
                if (recvPort.cachingInitiatedByMeSet.contains(spi)) {
                    Loggers.conLog.log(Level.INFO, "Got lost connection"
                            + " initiated by me. Connection now trully cached"
                            + " from {0} to {1}.",
                            new Object[]{spi, recvPort.identifier()});
                    /*
                     * The connection is cached because I wanted it cached.
                     * scenario 4)
                     */
                    /*
                     * Don't call port.cacheManager.cacheConnection() because
                     * this connection caching was initiated by me from some
                     * place, so I already know of this cached connection.
                     */
                    /*
                     * port.cacheManager.cacheConnection(me.identifier(), spi);
                     */
                    recvPort.cachingInitiatedByMeSet.remove(spi);
                    recvPort.cachingInitiatedByMeSet.notifyAll();

                    isCached = true;
                }
            }
            
            if (recvPort.toBeCachedSet.contains(spi)) {
                /*
                 * This disconnect call is actually a connection caching.
                 * scenario 2).
                 */
                recvPort.cacheManager.unReserveLiveToCacheConnection(recvPort.identifier(), spi);
                recvPort.toBeCachedSet.remove(spi);
                
                Loggers.conLog.log(Level.INFO, "Got lost connection. This"
                        + " connection will be cached because the send port {0} "
                        + " asked it.", spi);

                isCached = true;
            }
            
            if(isCached) {
                CacheStatistics.cache(recvPort.identifier(), spi);
                return ;
            }


            /*
             * The connection was cached (scenario 3) 
             * or 
             * it is alive (scenario 1),
             * but now it needs to be closed.
             */
            recvPort.cacheManager.removeConnection(recvPort.identifier(), spi);
            if (upcaller != null) {
                upcaller.lostConnection(recvPort, spi, reason);
            }
            
            CacheStatistics.remove(recvPort.identifier(), spi);
        } finally {
            recvPort.cacheManager.lock.unlock();
            Loggers.lockLog.log(Level.INFO, "Lock unlocked.");
        }
    }
}
