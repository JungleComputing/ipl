package ibis.ipl.impl.stacking.cache;

import ibis.ipl.ReceivePort;
import ibis.ipl.ReceivePortConnectUpcall;
import ibis.ipl.SendPortIdentifier;
import ibis.ipl.impl.stacking.cache.manager.CacheManager;
import java.util.logging.Level;

/**
 * This class forwards upcalls with the proper receive port.
 */
public class ReceivePortConnectionUpcaller
        implements ReceivePortConnectUpcall {

    CacheReceivePort port;
    ReceivePortConnectUpcall upcaller;

    public ReceivePortConnectionUpcaller(ReceivePortConnectUpcall upcaller,
            CacheReceivePort port) {
        this.port = port;
        this.upcaller = upcaller;
    }

    /*
     * Sync-ed so no lost connection may come when a connection upcall
     * is still alive.
     */
    @Override
    public synchronized boolean gotConnection(ReceivePort me,
            SendPortIdentifier spi) {
        Loggers.conLog.log(Level.INFO, "\t{0} got connection", port.identifier());

        boolean accepted = true;

        port.cacheManager.lock.lock();
        try {            
            if (port.cacheManager.isConnCached(this.port.identifier(), spi)) {
                Loggers.conLog.log(Level.INFO, "\t\trestoring from {0}\n", spi);
                // connection was cached
                port.cacheManager.restoreReservedConnection(port.identifier(), spi);
            } else {
                if (upcaller != null) {
                    accepted = upcaller.gotConnection(port, spi);
                }
                Loggers.conLog.log(Level.INFO, "\t\tnew from {0}\n", spi);
                // new connection
                port.cacheManager.activateReservedConnection(port.identifier(), spi);
            }
        } finally {
            port.cacheManager.lock.unlock();
        }

        return accepted;
    }

    /**
     * Synchronized in order to guarantee that at most 1 is alive at any time,
     * because this method is also called manually from the side channel
     * handling class.
     *
     * This method is called in one of the following situations: 1) a true
     * disconnect()/close() from the receive port 2) a connection caching (but
     * the SPI would be in the toBeCachedSet thanks to the side channel) 3) a
     * disconnect/close is called from the receive port, but the connection was
     * cached; (the disc/close is sent through the side channel; to mark this, I
     * set "me" to null) 4) a disconnect/close generated by a caching initiated
     * from this side; the side channel sends the caching msg to sendport and it
     * will close this connection.
     */
    @Override
    public synchronized void lostConnection(ReceivePort me,
            SendPortIdentifier spi, Throwable reason) {
        Loggers.conLog.log(Level.INFO, "\n\t{0} got lost connection to {1}",
                new Object[] {port.identifier(), spi});
        if (reason != null) {
            Loggers.conLog.log(Level.INFO, "\tcause was:\t{0}\n", reason.toString());
        }

        port.cacheManager.lock.lock();
        try {

            if (me == null) {
                /*
                 * The connection was cached, but now it needs to be closed.
                 * scenario 3).
                 */
                port.cacheManager.removeConnection(port.identifier(), spi);
            } else if (port.toBeCachedSet.contains(spi)) {
                /*
                 * This disconnect call is actually a connection caching.
                 * scenario 2).
                 */
                port.cacheManager.cacheConnection(me.identifier(), spi);
                port.toBeCachedSet.remove(spi);
            } else if (port.initiatedCachingByMe.contains(spi)) {
                /*
                 * The connection is cached because 
                 * I wanted it cached. scenario 4)
                 */
                /*
                 * Don't call port.cacheManager.cacheConnection()
                 * because this connection caching was initiated by
                 * me from some place, so I already know of this cached connection.
                 */
//                port.cacheManager.cacheConnection(me.identifier(), spi);
                /*
                 * Sync-ed because the place from where the caching was
                 * initiated would like a notification on when it has
                 * actually been accomplished.
                 */
                synchronized(port.initiatedCachingByMe) {
                    port.initiatedCachingByMe.remove(spi);
                    port.initiatedCachingByMe.notifyAll();
                }
            } else {
                /*
                 * This connection is lost for good - and it was't cached.
                 * scenario 1).
                 */
                port.cacheManager.removeConnection(me.identifier(), spi);
            }
        } finally {
            port.cacheManager.lock.unlock();
        }

        if (upcaller != null) {
            upcaller.lostConnection(port, spi, reason);
        }
    }
}
