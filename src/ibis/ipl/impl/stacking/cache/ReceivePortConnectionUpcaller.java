package ibis.ipl.impl.stacking.cache;

import ibis.ipl.ReceivePort;
import ibis.ipl.ReceivePortConnectUpcall;
import ibis.ipl.SendPortIdentifier;
import ibis.ipl.impl.stacking.cache.util.Loggers;
import java.util.logging.Level;

/**
 * This class forwards upcalls with the proper receive port.
 */
public class ReceivePortConnectionUpcaller
        implements ReceivePortConnectUpcall {

    CacheReceivePort recvPort;
    ReceivePortConnectUpcall upcaller;

    public ReceivePortConnectionUpcaller(ReceivePortConnectUpcall upcaller,
            CacheReceivePort port) {
        this.recvPort = port;
        this.upcaller = upcaller;
    }

    @Override
    public boolean gotConnection(ReceivePort me,
            SendPortIdentifier spi) {
        Loggers.conLog.log(Level.INFO, "\t{0} got connection", recvPort.identifier());

        boolean accepted = true;

        recvPort.cacheManager.lock.lock();
        Loggers.lockLog.log(Level.INFO, "Lock locked.");
        try {            
            if (recvPort.cacheManager.isConnCached(this.recvPort.identifier(), spi)) {
                Loggers.conLog.log(Level.INFO, "\t\trestoring from {0}\n", spi);
                // connection was cached
                recvPort.cacheManager.restoreReservedConnection(recvPort.identifier(), spi);
            } else {
                if (upcaller != null) {
                    Thread.currentThread().setPriority(Thread.MAX_PRIORITY);
                    accepted = upcaller.gotConnection(recvPort, spi);
                }
                Loggers.conLog.log(Level.INFO, "\t\tnew from {0}\n", spi);
                // new connection
                recvPort.cacheManager.activateReservedConnection(recvPort.identifier(), spi);
            }
        } finally {
            recvPort.cacheManager.lock.unlock();
            Loggers.lockLog.log(Level.INFO, "Lock unlocked.");
        }

        return accepted;
    }

    /**
     * This method is called in one of the following situations: 1) a true
     * disconnect()/close() from the receive port 2) a connection caching (but
     * the SPI would be in the toBeCachedSet thanks to the side channel) 3) a
     * disconnect/close is called from the receive port, but the connection was
     * cached; (the disc/close is sent through the side channel; to mark this, I
     * set "me" to null) 4) a disconnect/close generated by a caching initiated
     * from this side; the side channel sends the caching msg to sendport and it
     * will close this connection.
     */
    @Override
    public void lostConnection(ReceivePort me,
            SendPortIdentifier spi, Throwable reason) {
        Loggers.conLog.log(Level.INFO, "\n\t{0} got lost connection to {1}",
                new Object[] {recvPort.identifier(), spi});
        if (reason != null) {
            Loggers.conLog.log(Level.INFO, "\tcause was:\t{0}\n", reason.toString());
        }

        /*
         * Sync-ed because the place from where the caching was initiated would
         * like a notification on when it has actually been accomplished.
         */
        synchronized (recvPort.cachingInitiatedByMeSet) {
            if (recvPort.cachingInitiatedByMeSet.contains(spi)) {
                /*
                 * The connection is cached because I wanted it cached. scenario
                 * 4)
                 */
                /*
                 * Don't call port.cacheManager.cacheConnection() because this
                 * connection caching was initiated by me from some place, so I
                 * already know of this cached connection.
                 */
                /*
                 * port.cacheManager.cacheConnection(me.identifier(), spi);
                 */
                recvPort.cachingInitiatedByMeSet.remove(spi);
                recvPort.cachingInitiatedByMeSet.notifyAll();
                /*
                 * A SPI can be in both toBeCachedSet and
                 * cachingInitiatedByMeSet. scenario: simultaneously, both
                 * sendPort and recvPort want to cache the same connection.
                 */
                recvPort.toBeCachedSet.remove(spi);
                Loggers.conLog.log(Level.INFO, "Got lost connection"
                        + " initiated by me. Connection now trully cached"
                        + " from {0} to {1}.", 
                        new Object[] {spi, recvPort.identifier()});
                return;
            }
        }

        recvPort.cacheManager.lock.lock();
        Loggers.lockLog.log(Level.INFO, "Lock locked.");
        try {
            if (me == null) {
                /*
                 * The connection was cached, but now it needs to be closed.
                 * scenario 3).
                 */
                recvPort.cacheManager.removeConnection(recvPort.identifier(), spi);
                if (upcaller != null) {
                    Thread.currentThread().setPriority(Thread.MAX_PRIORITY);
                    upcaller.lostConnection(recvPort, spi, reason);
                }
                return;
            }
            
            if (recvPort.toBeCachedSet.contains(spi)) {
                /*
                 * This disconnect call is actually a connection caching.
                 * scenario 2).
                 */
                recvPort.cacheManager.unReserveLiveToCacheConnection(me.identifier(), spi);
                recvPort.toBeCachedSet.remove(spi);
            } else {
                /*
                 * This connection is lost for good - and it was't cached.
                 * scenario 1).
                 */
                recvPort.cacheManager.removeConnection(me.identifier(), spi);
                if (upcaller != null) {
                    Thread.currentThread().setPriority(Thread.MAX_PRIORITY);
                    upcaller.lostConnection(recvPort, spi, reason);
                }
            }
        } finally {
            recvPort.cacheManager.lock.unlock();
            Loggers.lockLog.log(Level.INFO, "Lock unlocked.");
        }
    }
}
